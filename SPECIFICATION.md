# Задание

## HashTable

Вам предстоит реализовать аналог контейнера `std::unordered_map` — ассоциативный массив на основе хеш-таблицы, который поддерживает отображение ключ -> значение, т.е. в соответствие каждому ключу ставится единственное значение, а все ключи уникальны.

Вы должны написать шаблон `HashMap`, который параметризуется типом ключа, типом значения и типом «хешера», иными словами, следующее:

```
template<class KeyType, class ValueType, class Hash = std::hash<KeyType> > class HashMap;
```

Скажем пару слов про «хешер». Это некоторый тип, который по ключу типа `KeyType` умеет выдавать значение типа `size_t`, которое можно получить, используя функциональный вызов. Например:

```
// пусть hasher имеет тип Hash
KeyType key = ...; // какой-то ключ
size_t num = hasher(key);
```

Благодаря использованию шаблонов, тип `Hash` может быть чем угодно — функцией, лямбдой или же классом, для которого перегружен оператор вызова `()`. Это позволяет пользователю вашего класса выбирать наиболее предпочтительный для него вариант хеш-функции. Если же пользователя устраивает стандартный вариант, то используется стандартный тип `std::hash<KeyType>`.

Обратите внимание, что сам по себе хешер всего лишь дает вам возможность получить для любого объекта некоторое число (и предоставляется пользователем класса, поскольку вы заранее не знаете, с какими типами будет использоваться ваша таблица), а вот как его использовать для организации быстрой хеш-таблицы — уже ваша забота. Однако же если хешер, например, возвращает для всех ключей число `0`, то ясно, что это проблема пользователя, а от вас мало что зависит (тем не менее, ваш класс должен по-прежнему корректно работать в таких ситуациях, это должно отражаться только на времени работы). Поэтому вы можете считать, что хешер распределяет ключи по диапазону `size_t` достаточно равномерно (в предположении, что ключи случайны) — в частности, это верно для умолчательного варианта `std::hash<KeyType>`.

Ваш класс должен содержать следующие конструкторы и методы:
- Конструктор по умолчанию.
- Конструктор, принимающий итераторы на начало и конец (точнее, следующий за концом) последовательности, каждый элемент которой представляет собой `std::pair<ключ, значение>`.
- Конструктор, принимающий `std::initializer_list` описанных выше пар.
- Все конструкторы также должны поддерживать возможность передачи объекта хешера (т.е. имеющего тип `Hash`) последним аргументом. В случае же, если таковой не передается, то используйте сконструированный по умолчанию.
- Методы `size` и `empty`, которые должны быть константными, и которые возвращают количество элементов в таблице и пуста ли она соответственно.
- Константный метод `hash_function`, который возвращает используемый таблицей хешер по значению.
- Метод `insert`, который принимает `std::pair<ключ, значение>` и добавляет в таблицу связь ключ -> значение. Если данный ключ уже имеется в таблице, то метод не должен ничего делать.
- Метод `erase`, который принимает ключ и удаляет соответствующую пару (ключ, значение) из таблицы. Если искомого ключа нет, то метод не должен ничего делать.
- Ваш класс должен предоставлять типы `iterator` и `const_iterator`, соответствующие итератору и константному итератору, с помощью которых можно было бы просмотреть содержимое таблицы, а также соответствующие методы `begin` и `end` для обоих типов итераторов, возвращающих итератор на начало контейнера и следующий за последним (как все контейнеры стандартной библиотеки). Итератор должен адресовывать значения типа `std::pair<const KeyType, ValueType>&`, а константный итератор — типа `const std::pair<const KeyType, ValueType>&`. Таким образом, с помощью обычного итератора можно изменять только значения в таблице (но не ключи), а с помощью константного итератора модификации невозможны совсем.
  - Обратите внимание, что итерирование по всей таблице должно занимать линейное время по числу вставленных элементов. Однако порядок, в котором перебираются элементы таблицы, может быть произвольным.
  - Итераторы должны быть, по крайней мере, `forward` — грубо говоря, поддерживать конструирование, инкремент, разыменовывание (через `*` и `->`), а также операторы сравнения `==` и `!=`. Более подробно можно ознакомиться тут: http://www.cplusplus.com/reference/iterator/ForwardIterator/.
  - Ваш класс может инвалидировать все итераторы после вставок и удалений. Иными словами, если из таблицы удаляется или вставляется элемент, то все имеющиеся на данный момент итераторы могут стать недействительными. Стандартный `std::unordered_map` при вызове `erase` инвалидирует только итераторы на удаленный элемент, остальные итераторы остаются действительными.
- Метод `find`, константный (возвращающий `const_iterator`) и нет (возвращающий `iterator`), который по переданному ключу возвращает итератор на соответствующую пару (ключ, значение), либо `end()`, если искомого ключа нет в таблице.
- Оператор `[]`, который по переданному ключу возвращает ссылку на соответствующее значение. Если же искомого ключа в таблице нет, то метод должен добавить в таблицу пару (ключ, значение по умолчанию) и вернуть соответствующую ссылку. Таким образом, можно будет писать что-то вроде
    ```
    HashMap<int, int> table;
    table[3] = 5;
    std::cout « table[3]; // выведет 5
    ```
- Константный метод `at`, который работает аналогично оператору `[]`, но возвращает константную ссылку на значение, а при отсутствии ключа генерирует исключение типа `std::out_of_range`.
- Метод `clear`, который очищает таблицу, удаляя все вставленные элементы. Обратите внимание, что метод должен работать за линейное время по количеству элементов в таблице.

Для сравнения ключей используйте только оператор `==`.

Если вы используете ручное управление памятью (например, вручную выделяете память через `new` вместо использования `std::vector`), то, разумеется, ваш класс также должен предоставлять правильно определенные конструктор копирования, оператор присваивания и деструктор.

#### Формат ввода
Всего будет не более 10^6 операций с таблицей.

#### Пример

**Ввод**
```
13
+ 3 5
+ 2 1
+ 0 7
? 0
- 0
? 0
? 2
+ 8 -4
<
!
? 3
+ 3 3
? 3
```

**Вывод**
```
7
-1
1
3 5
2 1
8 -4
-1
3
1
```


### UPDATE:

Кларификации по хешмапе

Про запрещённые хештаблицы: мотивация была в том, чтобы вы не бросались писать вещи, которые неоднократно реализовывали на контестах, а поискали более экзотические алгоритмы или хотя бы не столь популярные версии существующих. Я хочу явно запретить две реализации..
1) массив списков, где значение добавляется в список `bucket[hash(value) % bucket_count]`
2) таблица с открытой адресацией, где значение добавляется в позицию `table[hash(value) % table_size]`, а если она занята, то перебираются позиции с номером +1, +2, ..., пока не найдётся свободная. Выбирать другие тривиальные стратегию пробирования (т.е. поиска свободной ячейки), например, quadratic probing, тоже нельзя. Если сомневаетесь, можно или нет, можете спрашивать у меня в личке.

Использовать вариации этих алгоритмов можно, если они в каких-то деталях отличаются от упомянутых выше "стандартных". Например, необычный способ выбора баскета в списочной хештаблице или хитрый нетривиальный probing в таблице с открытой адресацией. Естественно, можно (и рекомендуется) поискать и найти другие хештаблицы, совершенно непохожие на эти две.

Про бонусы за непопулярные решения: критериев одинаковости реализаций у нас пока нет, будем решать коллегиально с семинаристами, когда увидим, какие работы сданы. Для примера, linear (+1) probing и quadratic probing я бы считал различными, но если бы набралось 20 разных таблиц с открытой адресацией, отличающихся только тривиальной функцией пробинга, критерии бы пересмотрели.

Про код-стайл: никакого жёсткого код-стайла нет, но нужно писать код так, как от вас бы ожидали на стажировке или коммите в open source. Разумный кодстайл, одинаковый на протяжении всего исходника (можно использовать google code style за референс, но если у вас выработался свой, то это не обязательно). Нормальные названия переменных. Общая чистота кода — достаточное количество пробелов, отсутствие гигантских функций и магических констант. О деталях поговорим на ревью.

Про время работы: если переданный пользователем хешер обладает k-независимостью для некоторого выбранного вами k, то ваша реализация должна выполнять любую операцию за ожидаемое константное время на любом фиксированном тесте. Если же хешер "плохой", то на время работы ограничений, естественно, не накладывается, но алгоритм тем не менее должен работать корректно.

Про дедлайн: хешмапу можно сдавать до 29 января, вс, 25:59 (да, это 01:59 следующего дня). Таким образом, остаётся чуть больше двух недель, этого вполне достаточно, на мой взгляд. К этому времени нужно сдать задачу и получить ОК в системе, ревью будет проходить позже. Сдавать, однако, нужно уже разумно выглядящий код: нельзя засабмитить абы что по методологии ХХП, а затем уже после дедлайна писать решение, соответствующее требованиям ревью.
